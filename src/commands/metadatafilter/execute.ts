import { Command, flags } from '@oclif/command'

export default class ExecuteFilter extends Command {
  static description = `Allows to filter metadatas folder generated by sfdx force:source:convert , using your own package.xml
  
  Metadata types currently managed:

  - ApexClass
  - ApexComponent
  - ApexPage
  - ApexTrigger
  - AuraDefinitionBundle
  - CustomApplication
  - CustomLabel
  - CustomMetadata
  - CustomObject
  - CustomObjectTranslation
  - CustomTab
  - Document
  - EmailTemplate
  - EscalationRules
  - FlexiPage
  - GlobalValueSet
  - GlobalValueSetTranslation
  - HomePageLayout
  - Layout
  - NamedCredential
  - PermissionSet
  - Profile
  - QuickAction
  - RemoteSiteSetting
  - Report
  - StandardValueSet
  - StaticResource
  - Translations
  - Workflow
  `

  static examples = [
    `$ sfdx metadatafilter:execute -p myPackage.xml`,
    `$ sfdx metadatafilter:execute -i md_api_output_dir -p myPackage.xml -o md_api_filtered_output_dir`,
  ]

  static flags = {
    // flag with a value (-n, --name=VALUE)
    packagexml: flags.string({ char: 'p', description: 'package.xml file path' }),
    inputfolder: flags.string({ char: 'i', description: 'Input folder (default: "." )' }),
    outputfolder: flags.string({ char: 'o', description: 'Output folder (default: filteredMetadatas)' })
  }

  static args = []

  // Input params properties
  packageXmlFile
  inputFolder
  outputFolder

  // Internal properties
  fs = require('fs')
  fse = require('fs-extra')
  xml2js = require('xml2js')
  util = require('util')
  path = require('path')
  packageXmlMetadatasTypeLs = []
  sobjectCollectedInfo = {}
  summaryResult = { metadataTypes: {} , objects: [] }

  // Runtime methods
  async run() {
    
    const { args, flags } = this.parse(ExecuteFilter)

    // Get input arguments or default values
    this.packageXmlFile = flags.packagexml
    this.inputFolder = flags.inputfolder || '.'
    this.outputFolder = flags.outputfolder || 'filteredMetadatas'
    this.log(`Initialize filtering of ${this.inputFolder} ,using ${this.packageXmlFile} , into ${this.outputFolder}`)

    // Read package.xml file
    var parser = new this.xml2js.Parser();
    var self = this
    this.fs.readFile(this.packageXmlFile, function (err, data) {
      parser.parseString(data, function (err2, result) {
        console.log(`Parsed package.xml \n` + self.util.inspect(result, false, null))

        // get metadata types in parse result
        try { self.packageXmlMetadatasTypeLs = result.Package.types }
        catch { throw 'Unable to parse packageXml file ' + self.packageXmlFile }

        // Create output folder/empty it if existing
        if (self.fs.existsSync(self.outputFolder)) {
          console.log('Empty target directory')
          self.fse.emptyDirSync(self.outputFolder);
        }
        else {
          self.fs.mkdirSync(self.outputFolder)
        }

        // Process source folder filtering and copy files into target folder
        self.filterMetadatasByType()
        self.copyImpactedObjects()
        self.displayResults()
      });
    });

  }

  // Filter metadatas by type
  filterMetadatasByType() {
    var self = this
    this.packageXmlMetadatasTypeLs.forEach(function (metadataDefinition) {
      var metadataType = metadataDefinition.name
      var members = metadataDefinition.members

      self.summaryResult.metadataTypes[metadataType] = { 'nbCopied': 0 }
      // Get metadata description
      var metadataDesc = self.getMetadataTypeDescription(metadataType)
      if (metadataDesc == null) {
        return
      }
      if (metadataDesc.folder != null)
         self.copyMetadataFiles(metadataDesc,metadataType,members)
      else if (metadataDesc.sobjectRelated === true)
        self.collectObjectDescription(metadataType,members) 

    });
  }

  copyMetadataFiles(metadataDesc,metadataType,members) {
      // Browse folder for matching files and copy them into target folder
      var typeInputFolder = this.inputFolder + '/' + metadataDesc.folder
      console.log(`- processing ${metadataType}`)
      if (this.fs.existsSync(typeInputFolder)) {
        var typeOutputFolder = this.outputFolder + '/' + metadataDesc.folder
        if (members != null && members[0] === '*') {
          // Wildcard: copy whole folder
          this.fse.copySync(typeInputFolder, typeOutputFolder)
        }
        else {
          // Create member folder in output folder
          this.fs.mkdirSync(typeOutputFolder)
          var self = this
          // Iterate all metadata types members (ApexClass,ApexComponent,etc...)
          members.forEach(function (member) {
            // Iterate all possible extensions ( '' for same file/folder name, '.cls' for ApexClass, etc ...)
            metadataDesc.nameSuffixList.forEach(function (nameSuffix) {
              // If input file/folder exists, copy it in output folder
              var sourceFile = typeInputFolder + '/' + member + nameSuffix
              if (self.fs.existsSync(sourceFile)) {
                var copyTargetFile = typeOutputFolder + '/' + member + nameSuffix
                self.fse.copySync(sourceFile, copyTargetFile)
                // Increment counter only when file is not meta-xml
                if (!sourceFile.endsWith('meta-xml')) {
                  self.summaryResult.metadataTypes[metadataType]['nbCopied']++
                }
              }
            })
          })

        }
      }
  }

  // Special case of SObjects: collect references to them in MetadataTypes
  collectObjectDescription(metadataType,members) {
    var self = this
    members.forEach(function (member) {
        var sobjectName = member.split('.')[0]
        var sobjectInfo = self.sobjectCollectedInfo[sobjectName] || {}
        if (metadataType != 'CustomObject' && member.split('.')[1] != null) {
        var sobjectInfoMetadataTypeList = sobjectInfo[metadataType] || []
          sobjectInfoMetadataTypeList.push(member.split('.')[1])
          sobjectInfo[metadataType] = sobjectInfoMetadataTypeList
        }
        self.sobjectCollectedInfo[sobjectName] = sobjectInfo
    })
  }

  // Describe packageXml <=> metadata folder correspondance
  describeMetadataTypes() {

    // folder is the corresponding folder in metadatas folder 
    // nameSuffixList are the files and/or folder names , built from the name of the package.xml item ( in <members> )

    const metadataTypesDescription = {
      // Metadatas to use for copy
      'ApexClass': { folder: 'classes', nameSuffixList: ['.cls', '.cls-meta.xml'] },
      'ApexComponent': { folder: 'components', nameSuffixList: ['.component', '.component-meta.xml'] },
      'ApexPage': { folder: 'pages', nameSuffixList: ['.page', '.page-meta.xml'] },
      'ApexTrigger': { folder: 'triggers', nameSuffixList: ['.trigger', '.trigger-meta.xml'] },
      'AuraDefinitionBundle': { folder: 'aura', nameSuffixList: [''] },
      'CustomApplication': { folder: 'applications', nameSuffixList: ['.app'] },
      'CustomLabel': { folder: 'labels', nameSuffixList: [''] },
      'CustomMetadata': { folder: 'customMetadata', nameSuffixList: ['.md'] },
      'CustomObjectTranslation': { folder: 'objectTranslations', nameSuffixList: ['.objectTranslation'] },
      'CustomTab': { folder: 'tabs', nameSuffixList: ['.tab'] },
      'Document': { folder: 'documents', nameSuffixList: ['', '-meta.xml'] },
      'EmailTemplate': { folder: 'email', nameSuffixList: ['', '-meta.xml'] },
      'EscalationRules': { folder: 'escalationRules', nameSuffixList: ['.escalationRules'] },
      'FlexiPage': { folder: 'flexipages', nameSuffixList: ['.flexipage'] },
      'GlobalValueSet': { folder: 'globalValueSets', nameSuffixList: ['.globalValueSet'] },
      'GlobalValueSetTranslation': { folder: 'globalValueSetTranslations', nameSuffixList: ['..globalValueSetTranslation'] },
      'HomePageLayout': { folder: 'homePageLayouts', nameSuffixList: ['.homePageLayout'] },
      'Layout': { folder: 'layouts', nameSuffixList: ['.layout'] },
      'NamedCredential': { folder: 'namedCredentials', nameSuffixList: ['.namedCredential'] },
      'PermissionSet': { folder: 'permissionsets', nameSuffixList: ['.permissionset'] },
      'Profile': { folder: 'profiles', nameSuffixList: ['.profile'] },
      'QuickAction': { folder: 'quickActions', nameSuffixList: ['.quickAction'] },
      'RemoteSiteSetting': { folder: 'remoteSiteSettings', nameSuffixList: ['.remoteSite'] },
      'Report': { folder: 'reports', nameSuffixList: ['', '-meta.xml'] },
      'StandardValueSet': { folder: 'standardValueSets', nameSuffixList: ['.standardValueSet'] },
      'StaticResource': { folder: 'staticresources', nameSuffixList: ['.resource', '.resource-meta.xml'] },
      'Translations': { folder: 'translations', nameSuffixList: ['.translation'] },
      'Workflow': { folder: 'workflows', nameSuffixList: ['.workflow'] },

      // Metadatas to use for building objects folder ( SObjects )
      'BusinessProcess': { sobjectRelated: true },
      'CustomField': { sobjectRelated: true },
      'CustomObject': { sobjectRelated: true },
      'ListView': {sobjectRelated: true },
      'RecordType': {sobjectRelated: true },
      'WebLink' : {sobjectRelated: true }

    }
    return metadataTypesDescription
  }

  // get Metadatype description
  getMetadataTypeDescription(md_type) {
    var desc = this.describeMetadataTypes()[md_type]
    return desc
  }

  // Copy objects based on information gathered with 'sobjectRelated' metadatas
  copyImpactedObjects() {
    var self = this
    Object.keys(this.sobjectCollectedInfo).forEach(function(objectName) {
      //NV:  Warning: this tool will be completed when .object file will be filtered to keep only related CustomFields, BusinessProcess, etc ... gathered from package.xml
      self.fse.copySync(self.inputFolder+'/objects/'+objectName+'.object', self.outputFolder+'/objects/'+objectName+'.object')
      self.summaryResult.objects.push(objectName)
    });
    self.summaryResult.objects.sort()
  }

  // Display results as JSON
  displayResults() {
    console.log(this.util.inspect(this.summaryResult, false, null))
  }


}